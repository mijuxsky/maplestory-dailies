<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MapleStory Dailies</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{
      --radius:12px; --shadow:0 6px 16px rgba(0,0,0,.12);
      --ui:14px; --overlay:rgba(0,0,0,.55);
      --bg:#f4f0fa; --fg:#4b3b60;
      --card-bg:#ffffff; --card-border:#e6def6;
      --control-bg:#ffffff; --control-fg:#4b3b60; --control-border:#cfc4ea;
      --button-bg:#e7def7; --button-fg:#3c2e54; --button-border:#cfc4ea;
      --icon:#7c5db0; --icon-bg:transparent; --icon-hover:rgba(124,93,176,.14);
      --task-underline:1px dotted currentColor;
      --name-underline:1px solid currentColor;
      --ph-outline:#7c5db0; --ph-bg:rgba(124,93,176,.10);
      --meta-fg:#6b7280;
    }
    body.light{ --bg:#f7f7f8; --fg:#333; --card-bg:#ffffff; --card-border:#e7e7ea; --control-bg:#ffffff; --control-fg:#222; --control-border:#d8d8dc; --button-bg:#ededf1; --button-fg:#222; --button-border:#d8d8dc; --icon:#555; --icon-bg:transparent; --icon-hover:rgba(0,0,0,.07); --ph-outline:#9aa0a6; --ph-bg:rgba(0,0,0,.04); --meta-fg:#6b7280;}
    body.cloud{ --bg:#eaf4ff; --fg:#2f4152; --card-bg:#ffffff; --card-border:#d6e7f7; --control-bg:#f6fbff; --control-fg:#2f4152; --control-border:#c7def2; --button-bg:#dcebfb; --button-fg:#213444; --button-border:#c4dcf5; --icon:#5a86b5; --icon-bg:transparent; --icon-hover:rgba(90,134,181,.14); --ph-outline:#5a86b5; --ph-bg:rgba(90,134,181,.10); --meta-fg:#6b7280;}
    body.lavender{ --bg:#f4f0fa; --fg:#4b3b60; --card-bg:#ffffff; --card-border:#e6def6; --control-bg:#ffffff; --control-fg:#4b3b60; --control-border:#cfc4ea; --button-bg:#e7def7; --button-fg:#3c2e54; --button-border:#cfc4ea; --icon:#7c5db0; --icon-bg:transparent; --icon-hover:rgba(124,93,176,.14); --ph-outline:#7c5db0; --ph-bg:rgba(124,93,176,.10); --meta-fg:#6b7280;}
    body.matcha{ --bg:#f0faf2; --fg:#2f3b2f; --card-bg:#e8f7ea; --card-border:#cfead4; --control-bg:#f7fdf8; --control-fg:#2f3b2f; --control-border:#cfead4; --button-bg:#d9f0de; --button-fg:#243224; --button-border:#c6e4cc; --icon:#4a8c4a; --icon-bg:transparent; --icon-hover:rgba(74,140,74,.14); --ph-outline:#4a8c4a; --ph-bg:rgba(74,140,74,.10); --meta-fg:#64748b;}
    body.dark{ --bg:#12131a; --fg:#e6e7eb; --card-bg:#1f2230; --card-border:#2c3144; --control-bg:#171925; --control-fg:#e6e7eb; --control-border:#2c3144; --button-bg:#2a2e42; --button-fg:#e6e7eb; --button-border:#3a4161; --icon:#cfd3df; --icon-bg:transparent; --icon-hover:rgba(255,255,255,.09); --ph-outline:#cfd3df; --ph-bg:rgba(207,211,223,.14); --meta-fg:#cbd5e1;}
    body.evergreen{ --bg:#0e1a11; --fg:#d9f2de; --card-bg:#1a2b1f; --card-border:#25402d; --control-bg:#132417; --control-fg:#d9f2de; --control-border:#284833; --button-bg:#23402c; --button-fg:#d9f2de; --button-border:#2e5640; --icon:#8bcf9b; --icon-bg:transparent; --icon-hover:rgba(139,207,155,.15); --ph-outline:#8bcf9b; --ph-bg:rgba(139,207,155,.16); --meta-fg:#d1d5db;}

    *{ box-sizing:border-box; }
    body{ font-family:Quicksand,system-ui,sans-serif; margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; font-size:var(--ui); background:var(--bg); color:var(--fg); transition:.25s background,.25s color; }
    h1{ margin:0 0 6px; font-size:20px; }
    #utc-time{ font-size:13px; margin-bottom:10px; }

    #instructions{ position:relative; width:100%; max-width:900px; margin:10px 0 14px; padding:12px 14px 14px; border-radius:12px; box-shadow:var(--shadow); background:var(--card-bg); border:1px solid var(--card-border); }
    #instructions.minimized ul{ display:none; }
    #instr-toggle{ position:absolute; top:8px; right:10px; padding:4px 10px; font-size:12px; background:var(--button-bg); color:var(--button-fg); border:1px solid var(--button-border); border-radius:8px; cursor:pointer; font-family:inherit; }

    .toolbar{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    label{ font-weight:600; font-size:var(--ui); opacity:.9; font-family:inherit; }

    .select-wrap{ position:relative; display:inline-flex; align-items:center; }
    .select-wrap::after{ content:'▾'; position:absolute; right:10px; pointer-events:none; opacity:.8; color:var(--control-fg); font-size:12px; }
    select{ appearance:none; -webkit-appearance:none; -moz-appearance:none; padding:6px 28px 6px 10px; border-radius:10px; border:1px solid var(--control-border); background:var(--control-bg); color:var(--control-fg); outline:none; font-family:inherit; font-size:var(--ui); }
    select:focus{ box-shadow:none; outline:none; }
    option{ background:var(--control-bg); color:var(--control-fg); }

    #add-character-btn{ padding:8px 12px; border-radius:10px; background:var(--button-bg); color:var(--button-fg); border:1px solid var(--button-border); font-weight:600; font-family:inherit; font-size:var(--ui); }
    #add-character-btn:hover{ filter:brightness(1.02); }
    #add-character-btn:active{ transform:translateY(1px); }

    #checklists{ display:grid; grid-template-columns:repeat(auto-fill,minmax(260px,1fr)); gap:20px; width:100%; max-width:1200px; align-items:start; }
    .character,.drop-placeholder{ border-radius:12px; box-shadow:var(--shadow); min-height:120px; position:relative; user-select:none; font-size:var(--ui); background:var(--card-bg); border:1px solid var(--card-border); }
    .character{ padding:48px 16px 12px; }
    .drop-placeholder{ padding:48px 16px 12px; outline:2px dashed var(--ph-outline); outline-offset:-6px; background:var(--ph-bg); animation:ph .6s ease-in-out infinite alternate; }
    @keyframes ph{ from{opacity:.72} to{opacity:1} }

    .window-controls-right{ position:absolute; top:6px; right:8px; display:flex; gap:6px; align-items:center; }
    .icon-btn{ width:24px; height:24px; border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:14px; padding:0; border:1px solid var(--control-border); background:var(--control-bg); color:var(--icon); transition:.15s background,.15s color,.15s border-color, transform .05s ease-in-out; font-family:inherit; }
    .icon-btn:hover{ background:var(--icon-hover); border-color:var(--control-border); }
    .icon-btn:active{ transform:translateY(1px); }
    .icon-btn svg{ width:16px; height:16px; }

    .char-image-wrap{ text-align:center; margin:0 auto 2px; min-height:24px; }
    .char-image-wrap img{ max-width:150px; max-height:110px; border-radius:8px; display:inline-block; }
    .char-meta{ text-align:center; font-size:12px; color:var(--meta-fg); margin:0 0 4px; font-family:inherit; }

    .char-name{ width:100%; border:none; background:transparent; border-bottom:var(--name-underline); text-align:center; font-weight:600; margin:2px 0 4px; font-size:var(--ui); color:var(--fg); font-family:inherit; }
    .char-name:focus{ outline:none; box-shadow:none; border-bottom:var(--name-underline); }

    .task{ display:grid; grid-template-columns:18px 1fr auto; gap:8px; align-items:center; margin:6px 0; }
    .task input[type="text"]{ border:none; border-bottom:var(--task-underline); background:transparent; padding:2px 2px; font-size:var(--ui); color:var(--fg); font-family:inherit; }
    .task input[type="text"]:focus{ outline:none; box-shadow:none; border-bottom:var(--task-underline); }
    .task .task-delete{ background:transparent; border:none; font-size:16px; opacity:.7; color:var(--icon); width:22px; height:22px; display:flex; align-items:center; justify-content:center; font-family:inherit; }

    /* Modal */
    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-overlay.show{ display:flex; }
    .modal{ background:#fff; color:#222; border:1px solid #ddd; border-radius:12px; padding:16px 16px 14px; min-width:320px; max-width:520px; width:min(520px,92vw); box-shadow:0 10px 28px rgba(0,0,0,.22); font-family:inherit; }
    .modal h3{ margin:0 0 12px; font-size:18px; font-weight:700; color:#111; letter-spacing:.2px; font-family:inherit; }
    .modal .row{ display:grid; grid-template-columns:1fr; gap:8px; margin:6px 0 10px; }
    .modal label{ font-weight:600; font-size:12px; color:#333; font-family:inherit; }
    .modal input[type="text"]{ width:100%; padding:8px 10px; border:1px solid #ccc; border-radius:8px; background:#fff; color:#111; font-family:inherit; font-size:var(--ui); }
    .modal .error{ color:#b00020; min-height:18px; font-size:12px; margin-top:2px; font-family:inherit; }
    .modal .actions{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:10px; }
    .modal .left-actions{ display:flex; gap:8px; }
    .modal .right-actions{ display:flex; gap:8px; }
    .modal .actions button{ padding:8px 12px; border-radius:8px; font-family:inherit; font-size:var(--ui); }
    .modal #avatar-upload{ background:#fff; color:#222; border:1px solid #d9d9d9; }
    .modal #avatar-delete{ background:#fff; color:#222; border:1px solid #e0e0e0; }
    .modal #avatar-cancel{ background:#f5f5f5; color:#222; border:1px solid #e5e5e5; }
    .modal #avatar-search{ background:#111; color:#fff; border:1px solid #111; }
  </style>
</head>
<body class="lavender">
  <h1>MapleStory Dailies</h1>
  <div id="utc-time">Loading UTC time...</div>

  <div id="instructions">
    <button id="instr-toggle" type="button">Hide</button>
    <strong>How to use:</strong>
    <ul id="howto">
      <li>Use <em>Theme</em> & <em>Preset</em> to style and switch between three saved sets.</li>
      <li>Click <strong>+ Add Character</strong> (max 20). Each starts with two task lines (min 1, max 10).</li>
      <li>Enter/Tab/↓ to next task (auto-adds). ↑/Shift+Tab up. ←/→ at edges to switch cards.</li>
      <li><strong>Reorder cards</strong> by dragging—drop anywhere in the grid; positions snap by row then column.</li>
      <li>Click the camera → <strong>Set Avatar</strong> popup: type the name and press <kbd>Enter</kbd> or click <strong>Set Avatar</strong> to pull the character model & stats from <strong>MapleRanks</strong>.</li>
      <li>Under the avatar, you’ll see <em>Lv. N Job</em>. Level & Job also auto-update after you type a <em>Character Name</em> on the card.</li>
      <li>Checkboxes reset at 00:00 UTC. All data is saved locally per preset.</li>
    </ul>
  </div>

  <div class="toolbar">
    <label for="theme">Theme:</label>
    <div class="select-wrap">
      <select id="theme">
        <option value="light">Light Mode</option>
        <option value="cloud">Cloud (Light)</option>
        <option value="lavender">Lavender (Light)</option>
        <option value="matcha">Matcha (Light)</option>
        <option value="dark">Dark Mode</option>
        <option value="evergreen">Evergreen (Dark)</option>
      </select>
    </div>

    <label for="preset">Preset:</label>
    <div class="select-wrap">
      <select id="preset">
        <option value="1">Preset 1</option>
        <option value="2">Preset 2</option>
        <option value="3">Preset 3</option>
      </select>
    </div>

    <button id="add-character-btn" title="Add Character">+ Add Character</button>
  </div>

  <div id="clipboard" aria-live="polite"></div>
  <div id="checklists"></div>

  <!-- Avatar search modal -->
  <div id="avatar-modal-overlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-labelledby="avatar-modal-title" aria-modal="true">
      <h3 id="avatar-modal-title">Set Avatar</h3>
      <div class="row">
        <label for="avatar-name">Character Name</label>
        <input id="avatar-name" type="text" placeholder="Enter character name" />
      </div>
      <div id="avatar-error" class="error"></div>
      <div class="actions">
        <div class="left-actions">
          <button id="avatar-upload" type="button">Upload Image</button>
          <button id="avatar-delete" type="button">Delete Avatar</button>
        </div>
        <div class="right-actions">
          <button id="avatar-cancel" type="button">Cancel</button>
          <button id="avatar-search" type="button">Set Avatar</button>
        </div>
      </div>
    </div>
  </div>

  <input id="hidden-upload" type="file" accept="image/*" style="display:none" />

  <script>
  // keep the UTC clock alive no matter what
  (function utcTick(){
    function tick(){
      const n=new Date(); const y=n.getUTCFullYear(); const m=String(n.getUTCMonth()+1).padStart(2,'0'); const d=String(n.getUTCDate()).padStart(2,'0'); const hh=String(n.getUTCHours()).padStart(2,'0'); const mm=String(n.getUTCMinutes()).padStart(2,'0'); const ss=String(n.getUTCSeconds()).padStart(2,'0');
      const el = document.getElementById('utc-time'); if(el) el.textContent=`UTC Time: ${m}/${d}/${y} ${hh}:${mm}:${ss}`;
    }
    tick(); setInterval(tick, 1000);
  })();

  (function main(){
    try{
      const PROXY_URL = "https://ms-avatar-proxy.meehoowee.workers.dev/";
      const BASE_MODEL_URL = "https://maplestory.io/api/character/%7B%22itemId%22%3A2000%2C%22version%22%3A%22250%22%7D%2C%7B%22itemId%22%3A12000%2C%22version%22%3A%22250%22%7D/stand1/0?showears=false&showLefEars=false&showHighLefEars=undefined&resize=1&name=&flipX=undefined";

      const MAX_W = 150, MAX_H = 110;
      let currentPreset = 1;
      const maxCharacters = 20;
      const maxTasks = 10;
      let dragFrom = null, avatarTargetIndex = null, uploadTargetIndex = null;
      let nameFetchTimers = {};

      const $ = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      function safeParse(json){ try{ return JSON.parse(json); }catch(_){ return null; } }
      function getDataKey() { return `mapleData_preset${currentPreset}`; }
      function loadData() {
        const raw = localStorage.getItem(getDataKey());
        const data = raw ? safeParse(raw) : null;
        if(!data) return { charCount: 1, 'char_0_taskCount': 2 };
        if(typeof data.charCount!=='number') data.charCount=1;
        if(data.charCount<1){ data.charCount=1; data['char_0_taskCount']=data['char_0_taskCount']||2; }
        return data;
      }
      function saveData(d) { localStorage.setItem(getDataKey(), JSON.stringify(d)); }
      function dailyKey(c,t) { return `mapleCheck_${new Date().toISOString().split('T')[0]}_preset${currentPreset}_c${c}_t${t}`; }

      function exportCharacters(d) {
        const list = []; const n = d.charCount||0;
        for (let i=0;i<n;i++) {
          const ct = Math.max(1, d[`char_${i}_taskCount`]||1);
          const tasks=[]; for (let t=0;t<ct;t++) tasks.push(d[`char_${i}_task_${t}`]||"");
          list.push({ name:d[`char_${i}_name`]||"", image:d[`char_${i}_image`]||"", level:d[`char_${i}_level`]||"", job:d[`char_${i}_job`]||"", tasks });
        }
        return list;
      }
      function importCharacters(chars) {
        const d={}; d.charCount=chars.length>0?chars.length:1;
        for (let i=0;i<d.charCount;i++) {
          const src = chars[i] || {name:"",image:"",level:"",job:"",tasks:["",""]};
          d[`char_${i}_name`]=src.name||""; d[`char_${i}_image`]=src.image||""; d[`char_${i}_level`]=src.level||""; d[`char_${i}_job`]=src.job||"";
          const tc = Math.max(1, Math.min(maxTasks,(src.tasks||[]).length||1));
          d[`char_${i}_taskCount`]=tc; for (let t=0;t<tc;t++) d[`char_${i}_task_${t}`]=src.tasks[t]||"";
        }
        saveData(d);
      }
      function ensureAtLeastOneCharacter(){
        const d=loadData();
        if((d.charCount||0)===0){ d.charCount=1; d[`char_0_taskCount`]=2; saveData(d); }
      }
      function moveCharacter(fr,to) {
        const d=loadData(); const arr=exportCharacters(d);
        if (fr===null||to===null||fr===to) return;
        const it=arr.splice(fr,1)[0]; arr.splice(to,0,it); importCharacters(arr); buildChecklists();
      }

      function addTaskLine(card,d,c) {
        let count=d[`char_${c}_taskCount`]||1;
        if(count<maxTasks){ d[`char_${c}_taskCount`]=count+1; saveData(d); return createTaskLine(card,d,c,count); }
        return null;
      }
      function focusTaskAt(card,idx){
        const arr=Array.from(card.querySelectorAll('.task input[type="text"]'));
        if(idx>=0&&idx<arr.length){ arr[idx].focus(); const e=arr[idx].value.length; arr[idx].setSelectionRange(e,e); return true;}
        return false;
      }
      function focusFirstTaskInCard(card){
        const el = card.querySelector('.task input[type="text"]') || card.querySelector('.char-name');
        if(el){ el.focus(); const e=el.value.length; el.setSelectionRange?.(e,e); return true; }
        return false;
      }
      function focusCardByOffset(card,off){
        const cards=$$('.character'); const i=cards.indexOf(card); const nx=i+off;
        if(nx<0||nx>=cards.length) return false;
        return focusFirstTaskInCard(cards[nx]);
      }

      async function fetchAvatarAndStats(name) {
        const resp = await fetch(`https://ms-avatar-proxy.meehoowee.workers.dev/?name=${encodeURIComponent(name)}`);
        const data = await resp.json().catch(()=>({}));
        if(!resp.ok) throw new Error(data && data.error || "Avatar fetch failed");
        return data;
      }

      function createTaskLine(card,d,c,t){
        const wrap=document.createElement('div'); wrap.className='task';
        const cb=document.createElement('input'); cb.type='checkbox';
        const key=dailyKey(c,t); cb.checked=(localStorage.getItem(key)==='true');
        cb.onchange=()=>localStorage.setItem(key, cb.checked?'true':'false');
        const input=document.createElement('input'); input.type='text'; input.placeholder='Daily Task'; input.value=d[`char_${c}_task_${t}`]||"";
        input.addEventListener('keydown',e=>{
          const inputs=Array.from(card.querySelectorAll('.task input[type="text"]')); const idx=inputs.indexOf(input);
          const atStart=input.selectionStart===0&&input.selectionEnd===0; const atEnd=input.selectionStart===input.value.length&&input.selectionEnd===input.value.length;
          if(e.key==='Enter'||(e.key==='Tab'&&!e.shiftKey)||(e.key==='ArrowDown'&&atEnd)){ if(e.key!=='ArrowDown') e.preventDefault(); if(!focusTaskAt(card,idx+1)){ const ni=addTaskLine(card,d,c); if(ni) ni.focus(); } }
          else if((e.key==='Tab'&&e.shiftKey)||(e.key==='ArrowUp'&&atStart)){ e.preventDefault(); if(!focusTaskAt(card,idx-1)) (card.querySelector('.char-name')||{}).focus?.(); }
          else if(e.key==='ArrowRight'&&atEnd){ e.preventDefault(); focusCardByOffset(card,+1); }
          else if(e.key==='ArrowLeft'&&atStart){ e.preventDefault(); focusCardByOffset(card,-1); }
        });
        input.addEventListener('input',()=>{
          if(input.value===""){
            const ct=d[`char_${c}_taskCount`]||1;
            if(ct>1){ wrap.remove(); delete d[`char_${c}_task_${t}`]; d[`char_${c}_taskCount`]=Math.max(1,ct-1); saveData(d); }
            else { delete d[`char_${c}_task_${t}`]; saveData(d); }
          } else { d[`char_${c}_task_${t}`]=input.value; saveData(d); }
        });
        const del=document.createElement('button'); del.className='task-delete'; del.title='Delete Task'; del.textContent='×';
        del.onclick=()=>{
          const ct=d[`char_${c}_taskCount`]||1;
          if(ct>1){ wrap.remove(); delete d[`char_${c}_task_${t}`]; d[`char_${c}_taskCount`]=Math.max(1,ct-1); saveData(d); }
          else { input.value=""; delete d[`char_${c}_task_${t}`]; saveData(d); }
        };
        wrap.append(cb,input,del); card.appendChild(wrap); return input;
      }

      function showCharImage(card,src){ const img=card.querySelector('.char-image-wrap img'); img.src=src||BASE_MODEL_URL; }
      function showCharMeta(card,level,job){
        const meta = card.querySelector('.char-meta');
        const parts=[]; if(level) parts.push(`Lv. ${level}`); if(job) parts.push(job);
        meta.textContent = parts.join(' ');
      }

      function buildChecklists(){
        const container=document.getElementById('checklists'); container.innerHTML='';

        const d=loadData();
        const total = Math.max(1, d.charCount||1);
        for(let c=0;c<total;c++){
          const card=document.createElement('div'); card.className='character'; card.setAttribute('draggable','true'); card.dataset.index=c;
          card.addEventListener('dragstart',e=>{ dragFrom=c; card.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; });
          card.addEventListener('dragend',()=>{ dragFrom=null; const dragging=$('.character.dragging'); dragging?.classList.remove('dragging'); });

          const topRight=document.createElement('div'); topRight.className='window-controls-right';
          const cam=document.createElement('button'); cam.className='icon-btn'; cam.title='Set Avatar'; cam.innerHTML='<svg viewBox="0 0 24 24"><path fill="currentColor" d="M9 3l-1.5 2H5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2.5L15 3H9zm3 4a5 5 0 1 1 0 10a5 5 0 0 1 0-10z"/></svg>';
          cam.onclick=()=>openAvatarModal(c,(loadData()[`char_${c}_name`]||""));
          const dup=document.createElement('button'); dup.className='icon-btn'; dup.title='Duplicate'; dup.innerHTML='<svg viewBox="0 0 24 24"><path fill="currentColor" d="M16 1H6a2 2 0 0 0-2 2v10h2V3h10V1zm-4 4h8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H12a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2zm0 2v10h8V7h-8z"/></svg>';
          dup.onclick=()=>duplicateCharacter(c);
          const close=document.createElement('button'); close.className='icon-btn'; close.title='Delete'; close.innerHTML='&times;';
          close.onclick=()=>deleteCharacter(c);
          topRight.append(cam,dup,close);
          card.appendChild(topRight);

          const imgWrap=document.createElement('div'); imgWrap.className='char-image-wrap'; imgWrap.innerHTML='<img alt="Character image" />'; card.appendChild(imgWrap);
          const meta=document.createElement('div'); meta.className='char-meta'; card.appendChild(meta);
          const cachedImg=(d[`char_${c}_image`]||"").trim(); showCharImage(card, cachedImg || BASE_MODEL_URL);
          showCharMeta(card, d[`char_${c}_level`]||"", d[`char_${c}_job`]||"");

          const name=document.createElement('input'); name.className='char-name'; name.placeholder='Character Name'; name.value=d[`char_${c}_name`]||"";
          name.addEventListener('input',()=>{
            const dd=loadData(); dd[`char_${c}_name`]=name.value; saveData(dd);
            const nm = name.value.trim();
            clearTimeout(nameFetchTimers[c]);
            if(nm.length >= 3){
              nameFetchTimers[c] = setTimeout(async ()=>{
                try{
                  const data = await fetchAvatarAndStats(nm);
                  const d2 = loadData();
                  d2[`char_${c}_level`] = data.level || "";
                  d2[`char_${c}_job`] = data.job || "";
                  if(!d2[`char_${c}_image`] || d2[`char_${c}_image`]===BASE_MODEL_URL){
                    if(data.imageUrl) d2[`char_${c}_image`] = data.imageUrl;
                  }
                  saveData(d2);
                  showCharMeta(card, d2[`char_${c}_level`], d2[`char_${c}_job`]);
                  if(d2[`char_${c}_image`]) showCharImage(card, d2[`char_${c}_image`]);
                }catch(_){ /* ignore */ }
              }, 700);
            }
          });
          name.addEventListener('keydown',e=>{
            const atStart=name.selectionStart===0&&name.selectionEnd===0; const atEnd=name.selectionStart===name.value.length&&name.selectionEnd===name.value.length;
            if(e.key==='Enter'){ e.preventDefault(); (card.querySelector('.task input[type="text"]')||{}).focus?.(); }
            else if(e.key==='ArrowRight'&&atEnd){ e.preventDefault(); focusCardByOffset(card,+1); }
            else if(e.key==='ArrowLeft'&&atStart){ e.preventDefault(); focusCardByOffset(card,-1); }
          });
          card.appendChild(name);

          let count=d[`char_${c}_taskCount`]; if(count==null) count=2; if(count<1) count=1; d[`char_${c}_taskCount`]=count;
          for(let t=0;t<count;t++) createTaskLine(card,d,c,t);
          saveData(d);
          container.appendChild(card);
        }

        attachGridDnD(container);
      }

      function attachGridDnD(container){
        let ph = document.createElement('div');
        ph.className = 'drop-placeholder';

        function getCards(){ return Array.from(container.querySelectorAll('.character:not(.dragging)')); }

        function computeInsertIndex(x,y){
          const cards = getCards();
          if(cards.length===0) return 0;
          const rects = cards.map(el=>({el, rect: el.getBoundingClientRect()}));
          rects.sort((a,b)=> (a.rect.top - b.rect.top) || (a.rect.left - b.rect.left));
          let best = 0, bestDist = Infinity;
          for(let i=0;i<rects.length;i++){
            const r = rects[i].rect;
            const cx = r.left + r.width/2;
            const cy = r.top + r.height/2;
            const dx = cx - x, dy = cy - y;
            const dist = dx*dx + dy*dy;
            if(dist < bestDist){ bestDist = dist; best = i; }
          }
          const r = rects[best].rect;
          const before = x < (r.left + r.width/2);
          return before ? best : best + 1;
        }

        function placePlaceholderAt(index){
          const cards = getCards();
          if(index <= 0){ if(container.firstElementChild !== ph) container.insertBefore(ph, container.firstElementChild); return; }
          if(index >= cards.length){ container.appendChild(ph); return; }
          const ref = cards[index]; if(ref && ref !== ph) container.insertBefore(ph, ref);
        }

        container.addEventListener('dragover', (e)=>{ e.preventDefault(); placePlaceholderAt(computeInsertIndex(e.clientX, e.clientY)); });
        container.addEventListener('drop', (e)=>{
          e.preventDefault();
          if(!ph.parentElement) return;
          let to = 0;
          for(const node of Array.from(container.children)){
            if(node===ph) break;
            if(node.classList.contains('character')) to++;
          }
          if(dragFrom !== null && dragFrom < to) to--;
          ph.remove();
          moveCharacter(dragFrom, to);
        });
      }

      function addCharacter(){
        const d=loadData(); if((d.charCount||0)>=20) return alert('Maximum of 20 characters reached.');
        const c=d.charCount||0; d.charCount=c+1; d[`char_${c}_taskCount`]=2; saveData(d); buildChecklists();
      }
      function duplicateCharacter(i){
        const d=loadData(); if((d.charCount||0)>=20) return alert('Maximum of 20 characters reached.');
        const arr=exportCharacters(d); const clone=JSON.parse(JSON.stringify(arr[i])); arr.splice(i+1,0,clone); importCharacters(arr); buildChecklists(); document.getElementById('clipboard').textContent='Character duplicated.';
      }
      function deleteCharacter(i){ const d=loadData(); const arr=exportCharacters(d); arr.splice(i,1); importCharacters(arr); buildChecklists(); }
      function switchPreset(p){ currentPreset=p; buildChecklists(); }

      // Theme + preset wiring
      (function initControls(){
        const themeSel = document.getElementById('theme');
        const presetSel = document.getElementById('preset');
        const addBtn = document.getElementById('add-character-btn');

        function loadTheme(){ const t=localStorage.getItem('mapleTheme')||'lavender'; document.body.className=t; themeSel.value=t; }
        themeSel.addEventListener('change',function(){ document.body.className=this.value; localStorage.setItem('mapleTheme',this.value); });
        presetSel.addEventListener('change',function(){ switchPreset(this.value); });
        addBtn.addEventListener('click', addCharacter);
        loadTheme();
      })();

      // Instructions hide
      (function initInstructions(){
        const instr=document.getElementById('instructions'); const toggle=document.getElementById('instr-toggle');
        function setInstr(min){ instr.classList.toggle('minimized',min); toggle.textContent=min?'Unhide':'Hide'; localStorage.setItem('mapleInstrMin',min?'1':'0'); }
        toggle.onclick=()=>setInstr(!instr.classList.contains('minimized'));
        setInstr(localStorage.getItem('mapleInstrMin')==='1');
      })();

      // Modal logic
      (function initModal(){
        const overlay=document.getElementById('avatar-modal-overlay');
        const nameInput=document.getElementById('avatar-name');
        const errBox=document.getElementById('avatar-error');

        window.openAvatarModal = function(cardIndex,prefill){
          avatarTargetIndex=cardIndex; errBox.textContent="";
          const inputVal = (prefill||"").trim();
          nameInput.value = inputVal;
          overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false'); nameInput.focus(); nameInput.select();
        };
        function closeAvatarModal(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); avatarTargetIndex=null; }
        document.getElementById('avatar-cancel').onclick=closeAvatarModal;
        document.getElementById('avatar-search').onclick=()=>doAvatarSearch();
        document.getElementById('avatar-delete').onclick=()=>doAvatarDelete();
        document.getElementById('avatar-upload').onclick=()=>{
          if(avatarTargetIndex==null) return;
          uploadTargetIndex = avatarTargetIndex;
          document.getElementById('hidden-upload').click();
        };
        nameInput.addEventListener('keydown',e=>{ if(e.key==='Enter') { e.preventDefault(); doAvatarSearch(); } });

        async function doAvatarSearch(){
          errBox.textContent=""; const nm=nameInput.value.trim();
          if(!nm){ errBox.textContent='Please enter a character name.'; return; }
          try{
            const data=await fetchAvatarAndStats(nm);
            const url=data.imageUrl; const level=data.level||""; const job=data.job||"";
            const cards=$$('.character'); const card=cards[avatarTargetIndex]; if(!card) throw new Error('Card not found');
            const d=loadData();
            d[`char_${avatarTargetIndex}_image`]=url||"";
            d[`char_${avatarTargetIndex}_name`]=nm;
            d[`char_${avatarTargetIndex}_level`]=level;
            d[`char_${avatarTargetIndex}_job`]=job;
            saveData(d);
            const nameField = card.querySelector('.char-name'); if(nameField) nameField.value = nm;
            showCharImage(card,url||"");
            showCharMeta(card, level, job);
            closeAvatarModal();
          }catch(e){
            const cards=$$('.character'); const card=cards[avatarTargetIndex];
            if(card){
              const d=loadData();
              d[`char_${avatarTargetIndex}_image`]=""; d[`char_${avatarTargetIndex}_level`]=""; d[`char_${avatarTargetIndex}_job`]=""; saveData(d);
              showCharImage(card, ""); showCharMeta(card, "", "");
            }
            errBox.textContent='Character image not found. Reverted to base model. Please verify the name and try again.';
          }
        }
        function doAvatarDelete(){
          const cards=$$('.character'); const card=cards[avatarTargetIndex];
          if(card){ const d=loadData(); d[`char_${avatarTargetIndex}_image`]=""; d[`char_${avatarTargetIndex}_level`]=""; d[`char_${avatarTargetIndex}_job`]=""; saveData(d); showCharImage(card,""); showCharMeta(card,"",""); }
          closeAvatarModal();
        }

        // Upload handling
        const hiddenUpload = document.getElementById('hidden-upload');
        hiddenUpload.addEventListener('change', async (e)=>{
          const file = e.target.files && e.target.files[0];
          if(!file || uploadTargetIndex==null) return;
          try{
            const dataUrl = await resizeImageFile(file, MAX_W, MAX_H);
            const d=loadData();
            d[`char_${uploadTargetIndex}_image`] = dataUrl; saveData(d);
            const cards=$$('.character'); const card=cards[uploadTargetIndex];
            if(card) showCharImage(card, dataUrl);
            closeAvatarModal();
          }catch(err){ alert('Could not load that image. Please try a different file.'); }
          finally{ e.target.value = ''; uploadTargetIndex = null; }
        });
      })();

      function resizeImageFile(file, maxW, maxH){
        return new Promise((resolve,reject)=>{
          const reader = new FileReader();
          reader.onload = ()=>{
            const img = new Image();
            img.onload = ()=>{
              const ratio = Math.min(maxW/img.width, maxH/img.height, 1);
              const nw = Math.round(img.width*ratio), nh = Math.round(img.height*ratio);
              const canvas = document.createElement('canvas');
              canvas.width = nw; canvas.height = nh;
              const ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
              ctx.drawImage(img, 0, 0, nw, nh);
              resolve(canvas.toDataURL('image/png'));
            };
            img.onerror = reject; img.src = reader.result;
          };
          reader.onerror = reject; reader.readAsDataURL(file);
        });
      }

      // Ensure at least one card & build
      ensureAtLeastOneCharacter();
      buildChecklists();

    }catch(err){
      console.error('Init failed:', err);
    }
  })();
  </script>
</body>
</html>
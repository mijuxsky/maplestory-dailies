<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MapleStory Dailies</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{
      --radius:12px; --shadow:0 6px 16px rgba(0,0,0,.12);
      --ui:14px; --overlay:rgba(0,0,0,.55);
      --bg:#f4f0fa; --fg:#4b3b60;
      --card-bg:#ffffff; --card-border:#e6def6;
      --control-bg:#ffffff; --control-fg:#4b3b60; --control-border:#cfc4ea;
      --button-bg:#e7def7; --button-fg:#3c2e54; --button-border:#cfc4ea;
      --icon:#7c5db0; --icon-bg:transparent; --icon-hover:rgba(124,93,176,.14);
      --task-underline:1px dotted currentColor;
      --name-underline:1px solid currentColor;
      --ph-outline:#7c5db0; --ph-bg:rgba(124,93,176,.08);
      --meta-fg:#6b7280;
    }
    body.light{ --bg:#f7f7f8; --fg:#333; --card-bg:#ffffff; --card-border:#e7e7ea; --control-bg:#ffffff; --control-fg:#222; --control-border:#d8d8dc; --button-bg:#ededf1; --button-fg:#222; --button-border:#d8d8dc; --icon:#555; --icon-bg:transparent; --icon-hover:rgba(0,0,0,.07); --ph-outline:#9aa0a6; --ph-bg:rgba(0,0,0,.04); --meta-fg:#6b7280;}
    body.cloud{ --bg:#eaf4ff; --fg:#2f4152; --card-bg:#ffffff; --card-border:#d6e7f7; --control-bg:#f6fbff; --control-fg:#2f4152; --control-border:#c7def2; --button-bg:#dcebfb; --button-fg:#213444; --button-border:#c4dcf5; --icon:#5a86b5; --icon-bg:transparent; --icon-hover:rgba(90,134,181,.14); --ph-outline:#8aaed2; --ph-bg:rgba(90,134,181,.10); --meta-fg:#6b7280;}
    body.lavender{ --bg:#f4f0fa; --fg:#4b3b60; --card-bg:#ffffff; --card-border:#e6def6; --control-bg:#ffffff; --control-fg:#4b3b60; --control-border:#cfc4ea; --button-bg:#e7def7; --button-fg:#3c2e54; --button-border:#cfc4ea; --icon:#7c5db0; --icon-bg:transparent; --icon-hover:rgba(124,93,176,.14); --ph-outline:#a79bc7; --ph-bg:rgba(124,93,176,.08); --meta-fg:#6b7280;}
    body.matcha{ --bg:#f0faf2; --fg:#2f3b2f; --card-bg:#e8f7ea; --card-border:#cfead4; --control-bg:#f7fdf8; --control-fg:#2f3b2f; --control-border:#cfead4; --button-bg:#d9f0de; --button-fg:#243224; --button-border:#c6e4cc; --icon:#4a8c4a; --icon-bg:transparent; --icon-hover:rgba(74,140,74,.14); --ph-outline:#8abf97; --ph-bg:rgba(74,140,74,.10); --meta-fg:#64748b;}
    body.dark{ --bg:#12131a; --fg:#e6e7eb; --card-bg:#1f2230; --card-border:#2c3144; --control-bg:#171925; --control-fg:#e6e7eb; --control-border:#2c3144; --button-bg:#2a2e42; --button-fg:#e6e7eb; --button-border:#3a4161; --icon:#cfd3df; --icon-bg:transparent; --icon-hover:rgba(255,255,255,.09); --ph-outline:#444b63; --ph-bg:rgba(207,211,223,.10); --meta-fg:#cbd5e1;}
    body.evergreen{ --bg:#0e1a11; --fg:#d9f2de; --card-bg:#1a2b1f; --card-border:#25402d; --control-bg:#132417; --control-fg:#d9f2de; --control-border:#284833; --button-bg:#23402c; --button-fg:#d9f2de; --button-border:#2e5640; --icon:#8bcf9b; --icon-bg:transparent; --icon-hover:rgba(139,207,155,.15); --ph-outline:#2f5840; --ph-bg:rgba(139,207,155,.16); --meta-fg:#d1d5db;}

    *{ box-sizing:border-box; }
    body{ font-family:Quicksand,system-ui,sans-serif; margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; font-size:var(--ui); background:var(--bg); color:var(--fg); transition:.25s background,.25s color; }
    h1{ margin:0 0 6px; font-size:20px; }
    #utc-time{ font-size:13px; margin-bottom:10px; }

    #instructions{ position:relative; width:100%; max-width:900px; margin:10px 0 14px; padding:12px 14px 14px; border-radius:12px; box-shadow:var(--shadow); background:var(--card-bg); border:1px solid var(--card-border); }
    #instructions.minimized ul{ display:none; }
    #instr-toggle{ position:absolute; top:8px; right:10px; padding:4px 10px; font-size:12px; background:var(--button-bg); color:var(--button-fg); border:1px solid var(--button-border); border-radius:8px; cursor:pointer; font-family:inherit; }

    .toolbar{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    label{ font-weight:600; font-size:var(--ui); opacity:.9; font-family:inherit; }

    .select-wrap{ position:relative; display:inline-flex; align-items:center; }
    .select-wrap::after{ content:'▾'; position:absolute; right:10px; pointer-events:none; opacity:.8; color:var(--control-fg); font-size:12px; }
    select{ appearance:none; -webkit-appearance:none; -moz-appearance:none; padding:6px 28px 6px 10px; border-radius:10px; border:1px solid var(--control-border); background:var(--control-bg); color:var(--control-fg); outline:none; font-family:inherit; font-size:var(--ui); }
    select:focus{ box-shadow:none; outline:none; }
    option{ background:var(--control-bg); color:var(--control-fg); }

    #add-character-btn, #export-btn, #import-btn{ padding:8px 12px; border-radius:10px; background:var(--button-bg); color:var(--button-fg); border:1px solid var(--button-border); font-weight:600; font-family:inherit; font-size:var(--ui); }
    #add-character-btn:hover, #export-btn:hover, #import-btn:hover{ filter:brightness(1.02); }
    #add-character-btn:active, #export-btn:active, #import-btn:active{ transform:translateY(1px); }

    #checklists{ display:grid; grid-template-columns:repeat(auto-fill,minmax(260px,1fr)); gap:20px; width:100%; max-width:1200px; align-items:start; }
    .character,.drop-placeholder{ border-radius:12px; box-shadow:var(--shadow); min-height:120px; position:relative; user-select:none; font-size:var(--ui); background:var(--card-bg); border:1px solid var(--card-border); }
    .character{ padding:48px 16px 12px; transition:transform .08s ease, opacity .08s ease; will-change: transform; }
    .character.dragging{ opacity:.96; transform:scale(.985); }
    .drop-placeholder{ padding:48px 16px 12px; border:1px dotted var(--ph-outline); border-radius:12px; background:transparent; opacity:.28; outline:none; box-shadow:none; pointer-events:none; }

    .window-controls-right{ position:absolute; top:6px; right:8px; display:flex; gap:6px; align-items:center; }
    .icon-btn{ width:24px; height:24px; border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:14px; padding:0; border:1px solid var(--control-border); background:var(--control-bg); color:var(--icon); transition:.15s background,.15s color,.15s border-color, transform .05s ease-in-out; font-family:inherit; }
    .icon-btn:hover{ background:var(--icon-hover); border-color:var(--control-border); }
    .icon-btn:active{ transform:translateY(1px); }
    .icon-btn svg{ width:16px; height:16px; }

    .char-image-wrap{ text-align:center; margin:0 auto 2px; min-height:24px; }
    .char-image-wrap img{ max-width:150px; max-height:110px; border-radius:8px; display:inline-block; }
    .char-meta{ text-align:center; font-size:12px; color:var(--meta-fg); margin:0 0 6px; font-family:inherit; }

    .char-name{ width:100%; border:none; background:transparent; border-bottom:var(--name-underline); text-align:center; font-weight:600; margin:2px 0 6px; font-size:var(--ui); color:var(--fg); font-family:inherit; }
    .char-name:focus{ outline:none; box-shadow:none; border-bottom:var(--name-underline); }

    .checkall-row{ display:flex; align-items:center; gap:8px; justify-content:flex-end; margin:2px 0 6px; }
    .checkall-row label{ font-size:12px; opacity:.8; }

    .task{ display:grid; grid-template-columns:18px 18px 1fr auto; gap:8px; align-items:center; margin:6px 0; }
    .drag-handle{ background:transparent; border:none; color:var(--icon); cursor:grab; width:18px; height:22px; display:flex; align-items:center; justify-content:center; font-size:14px; opacity:.7; font-family:inherit; }
    .drag-handle:active{ cursor:grabbing; opacity:.95; }
    .task input[type="text"]{ border:none; border-bottom:var(--task-underline); background:transparent; padding:2px 2px; font-size:var(--ui); color:var(--fg); font-family:inherit; }
    .task input[type="text"]:focus{ outline:none; box-shadow:none; border-bottom:var(--task-underline); }
    .task .task-delete{ background:transparent; border:none; font-size:16px; opacity:.7; color:var(--icon); width:22px; height:22px; display:flex; align-items:center; justify-content:center; font-family:inherit; }

    .task.placeholder{ border:1px dotted var(--ph-outline); border-radius:8px; min-height:26px; opacity:.5; }
    .task.placeholder .drag-handle, .task.placeholder input, .task.placeholder .task-delete{ visibility:hidden; }
    .task.dragging{ opacity:.8; }

    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-overlay.show{ display:flex; }
    .modal{ background:#fff; color:#222; border:1px solid #ddd; border-radius:12px; padding:16px 16px 14px; min-width:320px; max-width:520px; width:min(520px,92vw); box-shadow:0 10px 28px rgba(0,0,0,.22); font-family:inherit; }
    .modal h3{ margin:0 0 12px; font-size:18px; font-weight:700; color:#111; letter-spacing:.2px; font-family:inherit; }
    .modal .row{ display:grid; grid-template-columns:1fr; gap:8px; margin:6px 0 10px; }
    .modal label{ font-weight:600; font-size:12px; color:#333; font-family:inherit; }
    .modal input[type="text"]{ width:100%; padding:8px 10px; border:1px solid #ccc; border-radius:8px; background:#fff; color:#111; font-family:inherit; font-size:var(--ui); }
    .modal .error{ color:#b00020; min-height:18px; font-size:12px; margin-top:2px; font-family:inherit; }
    .modal .actions{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:10px; }
    .modal .left-actions{ display:flex; gap:8px; }
    .modal .right-actions{ display:flex; gap:8px; }
    .modal .actions button{ padding:8px 12px; border-radius:8px; font-family:inherit; font-size:var(--ui); }
    .modal #avatar-upload{ background:#fff; color:#222; border:1px solid #d9d9d9; }
    .modal #avatar-delete{ background:#fff; color:#222; border:1px solid #e0e0e0; }
    .modal #avatar-cancel{ background:#f5f5f5; color:#222; border:1px solid #e5e5e5; }
    .modal #avatar-search{ background:#111; color:#fff; border:1px solid #111; }

    .modal.confirm{ background:#fff; color:#111; border:1px solid #ddd; }
    body.dark .modal.confirm, body.evergreen .modal.confirm{ background:#101214; color:#e7e9ee; border:1px solid #2b2f3a; }
    .modal.confirm h3{ margin:0 0 10px; font-size:16px; letter-spacing:.2px; }
    .modal.confirm p{ margin:0 0 12px; font-size:13px; opacity:.9; }
    .modal.confirm .actions{ display:flex; justify-content:flex-end; gap:8px; }
    .modal.confirm .actions button{ padding:8px 12px; border-radius:8px; font:inherit; font-size:inherit; border:1px solid var(--control-border); }
    .modal.confirm .actions .danger{ background:#111; color:#fff; border-color:#111; }
    body.dark .modal.confirm .actions .danger, body.evergreen .modal.confirm .actions .danger{ background:#e7e9ee; color:#101214; border-color:#e7e9ee; }
  </style>
</head>
<body class="lavender">
  <h1>MapleStory Dailies</h1>
  <div id="utc-time">Loading UTC time...</div>

  <div id="instructions">
    <button id="instr-toggle" type="button">Hide</button>
    <strong>How to use:</strong>
    <ul id="howto">
      <li><strong>Themes & Presets:</strong> Choose a Theme and one of 3 Presets (saved locally).</li>
      <li><strong>Add Characters:</strong> Click <em>+ Add Character</em> (max 20). Starts with 2 task lines (min 1, max 10).</li>
      <li><strong>Navigating with keyboard:</strong> Enter/Tab/↓ to next task (auto-adds). ↑/Shift+Tab up. ←/→ at edges to switch cards.</li>
      <li><strong>Reorder cards:</strong> Drag any card; drop anywhere in the grid. Smooth, snap-by-row then column.</li>
      <li><strong>Reorder tasks:</strong> Drag the <em>⋮⋮</em> handle to move a task; or press <em>Enter</em> to insert a task under the current one.</li>
      <li><strong>Update characters:</strong> Camera → <em>Set Avatar</em> popup. Or type a name in the card and press Enter/blur to auto-fetch avatar + Lv./Class from MapleRanks.</li>
      <li><strong>Import/Export:</strong> Use <em>Export</em> (JSON file) and <em>Import</em> to move your data between devices—no servers.</li>
      <li><strong>Daily reset:</strong> Checkboxes reset automatically at 00:00 UTC.</li>
    </ul>
  </div>

  <div class="toolbar">
    <label for="theme">Theme:</label>
    <div class="select-wrap">
      <select id="theme">
        <option value="light">Light Mode</option>
        <option value="cloud">Cloud (Light)</option>
        <option value="lavender">Lavender (Light)</option>
        <option value="matcha">Matcha (Light)</option>
        <option value="dark">Dark Mode</option>
        <option value="evergreen">Evergreen (Dark)</option>
      </select>
    </div>

    <label for="preset">Preset:</label>
    <div class="select-wrap">
      <select id="preset">
        <option value="1">Preset 1</option>
        <option value="2">Preset 2</option>
        <option value="3">Preset 3</option>
      </select>
    </div>

    <button id="add-character-btn" title="Add Character">+ Add Character</button>
    <button id="export-btn" title="Export data">Export</button>
    <button id="import-btn" title="Import data">Import</button>
    <input id="import-file" type="file" accept="application/json" hidden>
  </div>

  <div id="clipboard" aria-live="polite"></div>
  <div id="checklists"></div>

  <!-- Avatar search modal -->
  <div id="avatar-modal-overlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-labelledby="avatar-modal-title" aria-modal="true">
      <h3 id="avatar-modal-title">Set Avatar</h3>
      <div class="row">
        <label for="avatar-name">Character Name</label>
        <input id="avatar-name" type="text" placeholder="Enter character name" />
      </div>
      <div id="avatar-error" class="error"></div>
      <div class="actions">
        <div class="left-actions">
          <button id="avatar-upload" type="button">Upload Image</button>
          <button id="avatar-delete" type="button">Delete Avatar</button>
        </div>
        <div class="right-actions">
          <button id="avatar-cancel" type="button">No</button>
          <button id="avatar-search" type="button">Set Avatar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Delete confirmation modal -->
  <div id="confirm-overlay" class="modal-overlay" aria-hidden="true">
    <div class="modal confirm" role="dialog" aria-labelledby="confirm-title" aria-modal="true">
      <h3 id="confirm-title">Confirm Delete</h3>
      <p id="confirm-msg">Are you sure you want to delete this character?</p>
      <div class="actions">
        <button id="confirm-cancel" type="button">No</button>
        <button id="confirm-ok" type="button" class="danger">Yes</button>
      </div>
    </div>
  </div>

  <input id="hidden-upload" type="file" accept="image/*" style="display:none" />

  <script>
  // UTC clock
  (function tickUTC(){
    function tick(){
      const n=new Date(); const y=n.getUTCFullYear(); const m=String(n.getUTCMonth()+1).padStart(2,'0'); const d=String(n.getUTCDate()).padStart(2,'0'); const hh=String(n.getUTCHours()).padStart(2,'0'); const mm=String(n.getUTCMinutes()).padStart(2,'0'); const ss=String(n.getUTCSeconds()).padStart(2,'0');
      const el = document.getElementById('utc-time'); if(el) el.textContent=`UTC Time: ${m}/${d}/${y} ${hh}:${mm}:${ss}`;
    }
    tick(); setInterval(tick, 1000);
  })();

  (function main(){
    try{
      const PROXY_URL = "https://ms-avatar-proxy.meehoowee.workers.dev/";
      const BASE_MODEL_URL = "https://maplestory.io/api/character/%7B%22itemId%22%3A2000%2C%22version%22%3A%22250%22%7D%2C%7B%22itemId%22%3A12000%2C%22version%22%3A%22250%22%7D/stand1/0?showears=false&showLefEars=false&showHighLefEars=undefined&resize=1&name=&flipX=undefined";

      const MAX_W = 150, MAX_H = 110;
      let currentPreset = 1;
      const maxCharacters = 20;
      const maxTasks = 10;
      let avatarTargetIndex = null, uploadTargetIndex = null;
      let pendingFocus = null;
      let gridDnDBound = false;

      const $ = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      /* ========= Schema v2 (array-based) ========= */
      function getDataKey(){ return `mapleData_preset${currentPreset}`; }
      function migrateV1toV2(objV1){
        const out = { version:2, chars:[] };
        const n = Math.max(1, objV1.charCount||1);
        for(let i=0;i<n;i++){
          const ct = Math.max(1, objV1[`char_${i}_taskCount`]||1);
          const tasks = [];
          for(let t=0;t<ct;t++) tasks.push(objV1[`char_${i}_task_${t}`]||"");
          out.chars.push({ name: objV1[`char_${i}_name`]||"", image: objV1[`char_${i}_image`]||"", level: objV1[`char_${i}_level`]||"", job: objV1[`char_${i}_job`]||"", tasks });
        }
        return out;
      }
      function ensureValidV2(data){
        if(!data || typeof data!=='object' || data.version!==2) return null;
        if(!Array.isArray(data.chars)) data.chars = [];
        if(data.chars.length===0) data.chars.push({name:"",image:"",level:"",job:"",tasks:["",""]});
        for(const ch of data.chars){
          if(!Array.isArray(ch.tasks)) ch.tasks=[];
          if(ch.tasks.length===0) ch.tasks.push("");
          if(ch.tasks.length>maxTasks) ch.tasks = ch.tasks.slice(0,maxTasks);
        }
        return data;
      }
      function loadData(){
        const raw = localStorage.getItem(getDataKey());
        if(!raw){
          const d={ version:2, chars:[{name:"",image:"",level:"",job:"",tasks:["",""]}] };
          return d;
        }
        let parsed; try{ parsed=JSON.parse(raw); }catch{ parsed=null; }
        if(!parsed) return { version:2, chars:[{name:"",image:"",level:"",job:"",tasks:["",""]}] };
        if(parsed.version===2) return ensureValidV2(parsed);
        const v2 = migrateV1toV2(parsed); saveData(v2); return ensureValidV2(v2);
      }
      function saveData(d){ localStorage.setItem(getDataKey(), JSON.stringify(ensureValidV2(d))); }

      function dailyKey(c,t){ return `mapleCheck_${new Date().toISOString().split('T')[0]}_preset${currentPreset}_c${c}_t${t}`; }

      function addCharacter(){
        const d=loadData();
        if(d.chars.length>=maxCharacters){ alert('Maximum of 20 characters reached.'); return; }
        d.chars.push({name:"",image:"",level:"",job:"",tasks:["",""]});
        saveData(d); buildChecklists();
      }
      function duplicateCharacter(i){
        const d=loadData();
        if(d.chars.length>=maxCharacters){ alert('Maximum of 20 characters reached.'); return; }
        const clone = JSON.parse(JSON.stringify(d.chars[i]));
        d.chars.splice(i+1,0,clone);
        saveData(d); buildChecklists();
        document.getElementById('clipboard').textContent='Character duplicated.';
      }
      async function deleteCharacter(i){
        const d=loadData();
        const nm = (d.chars[i]?.name||'').trim() || 'Unnamed';
        const yes = await confirmDeleteModal(nm);
        if(!yes) return;
        d.chars.splice(i,1);
        if(d.chars.length===0) d.chars.push({name:"",image:"",level:"",job:"",tasks:["",""]});
        saveData(d); buildChecklists();
      }

      function moveCharacter(from,to){
        const d=loadData();
        if(from==null||to==null||from===to) return;
        const it = d.chars.splice(from,1)[0];
        d.chars.splice(to,0,it);
        saveData(d); buildChecklists();
      }

      function insertTaskAfterIndex(d,c,idx){
        const ch=d.chars[c];
        if(ch.tasks.length>=maxTasks) return false;
        ch.tasks.splice(idx+1,0,"");
        saveData(d); return true;
      }
      function swapTasksInData(d,c,from,to){
        const ch=d.chars[c];
        const it = ch.tasks.splice(from,1)[0];
        ch.tasks.splice(to,0,it);
        saveData(d);
      }

      function showCharImage(card,src){ const img=card.querySelector('.char-image-wrap img'); img.src=src||BASE_MODEL_URL; }
      function showCharMeta(card,level,job){
        const meta = card.querySelector('.char-meta');
        const parts=[]; if(level) parts.push(`Lv. ${level}`); if(job) parts.push(job);
        meta.textContent = parts.join(' ');
      }

      function createTaskLine(card,d,c,t){
        const wrap=document.createElement('div'); wrap.className='task'; wrap.dataset.taskIndex=t; wrap.draggable=false;

        const grip=document.createElement('button'); grip.className='drag-handle'; grip.title='Drag to reorder'; grip.textContent='⋮⋮';
        grip.addEventListener('mousedown',()=>{ wrap.draggable=true; });
        grip.addEventListener('mouseup',()=>{ wrap.draggable=false; });
        grip.addEventListener('mouseleave',()=>{ wrap.draggable=false; });

        const cb=document.createElement('input'); cb.type='checkbox';
        const key=dailyKey(c,t); cb.checked=(localStorage.getItem(key)==='true');
        cb.onchange=()=>{ localStorage.setItem(key, cb.checked?'true':'false'); refreshMaster(card,c); };

        const input=document.createElement('input'); input.type='text'; input.placeholder='Daily Task'; input.value=d.chars[c].tasks[t]||"";
        input.addEventListener('keydown',e=>{
          const inputs=Array.from(card.querySelectorAll('.task input[type="text"]')); const idx=inputs.indexOf(input);
          const atStart=input.selectionStart===0&&input.selectionEnd===0; const atEnd=input.selectionStart===input.value.length&&input.selectionEnd===input.value.length;
          if(e.key==='Enter'){
            e.preventDefault();
            const dd=loadData();
            if(insertTaskAfterIndex(dd,c,idx)){
              pendingFocus={cardIndex:c, taskIndex:idx+1};
              buildChecklists();
            }else{
              if(!focusTaskAt(card,idx+1)) { const ni=addTaskLine(card,dd,c); if(ni) ni.focus(); }
            }
          }
          else if((e.key==='Tab'&&!e.shiftKey)||(e.key==='ArrowDown'&&atEnd)){
            if(e.key!=='ArrowDown') e.preventDefault();
            if(!focusTaskAt(card,idx+1)){ const ni=addTaskLine(card,loadData(),c); if(ni) ni.focus(); }
          }
          else if((e.key==='Tab'&&e.shiftKey)||(e.key==='ArrowUp'&&atStart)){
            e.preventDefault(); if(!focusTaskAt(card,idx-1)) (card.querySelector('.char-name')||{}).focus?.();
          }
          else if(e.key==='ArrowRight'&&atEnd){ e.preventDefault(); focusCardByOffset(card,+1); }
          else if(e.key==='ArrowLeft'&&atStart){ e.preventDefault(); focusCardByOffset(card,-1); }
        });
        input.addEventListener('input',()=>{
          const dd=loadData();
          if(input.value===""){
            if(dd.chars[c].tasks.length>1){
              dd.chars[c].tasks.splice(t,1);
              saveData(dd); buildChecklists();
            } else {
              dd.chars[c].tasks[0] = "";
              saveData(dd);
            }
          } else {
            dd.chars[c].tasks[t]=input.value; saveData(dd);
          }
        });

        const del=document.createElement('button'); del.className='task-delete'; del.title='Delete Task'; del.textContent='×';
        del.onclick=()=>{
          const dd=loadData();
          if(dd.chars[c].tasks.length>1){
            dd.chars[c].tasks.splice(t,1); saveData(dd); buildChecklists();
          } else {
            dd.chars[c].tasks[0]=""; saveData(dd);
          }
        };

        wrap.append(grip,cb,input,del); card.appendChild(wrap); return input;
      }

      function addTaskLine(card,d,c){
        const ch = d.chars[c];
        if(ch.tasks.length>=maxTasks) return null;
        ch.tasks.push(""); saveData(d);
        const idx = ch.tasks.length-1;
        return createTaskLine(card,d,c,idx);
      }

      function focusTaskAt(card,idx){
        const arr=Array.from(card.querySelectorAll('.task input[type="text"]'));
        if(idx>=0&&idx<arr.length){ arr[idx].focus(); const e=arr[idx].value.length; arr[idx].setSelectionRange(e,e); return true;}
        return false;
      }
      function focusFirstTaskInCard(card){
        const el = card.querySelector('.task input[type="text"]') || card.querySelector('.char-name');
        if(el){ el.focus(); const e=el.value.length; el.setSelectionRange?.(e,e); return true; }
        return false;
      }
      function focusCardByOffset(card,off){
        const cards=$$('.character'); const i=cards.indexOf(card); const nx=i+off;
        if(nx<0||nx>=cards.length) return false;
        return focusFirstTaskInCard(cards[nx]);
      }

      /* ========= Card-level DnD ========= */
      let lastX=0, lastY=0, rafId=null, cardRects=[];
      function precomputeCardRects(container){
        const cards = Array.from(container.querySelectorAll('.character:not(.dragging)'));
        cardRects = cards.map(el => el.getBoundingClientRect());
      }
      function computeInsertIndexFromRects(x,y){
        if(!cardRects.length) return 0;
        let best = 0, bestDist = Infinity;
        for(let i=0;i<cardRects.length;i++){
          const r = cardRects[i];
          const cx = r.left + r.width/2;
          const cy = r.top + r.height/2;
          const dx = cx - x, dy = cy - y;
          const dist = dx*dx + dy*dy;
          if (dist < bestDist) { bestDist = dist; best = i; }
        }
        const r = cardRects[best];
        const before = x < (r.left + r.width/2);
        return before ? best : best + 1;
      }
      function attachGridDnD(container){
        const ph = document.createElement('div'); ph.className='drop-placeholder';
        function placePlaceholderAt(index){
          const cards = Array.from(container.querySelectorAll('.character:not(.dragging)'));
          if (index <= 0) { if(container.firstElementChild !== ph) container.insertBefore(ph, container.firstElementChild); return; }
          if (index >= cards.length) { container.appendChild(ph); return; }
          const ref = cards[index]; if (ref && ref !== ph) container.insertBefore(ph, ref);
        }
        container.addEventListener('dragstart', (e)=>{
          const card = e.target.closest('.character'); if(!card) return;
          precomputeCardRects(container);
          placePlaceholderAt(Array.from(container.querySelectorAll('.character:not(.dragging)')).indexOf(card) + 1);
        });
        container.addEventListener('dragover', (e)=>{
          e.preventDefault();
          lastX = e.clientX; lastY = e.clientY;
          if (rafId) return;
          rafId = requestAnimationFrame(()=>{
            rafId = null;
            const idx = computeInsertIndexFromRects(lastX, lastY);
            placePlaceholderAt(idx);
          });
        });
        container.addEventListener('drop', (e)=>{
          e.preventDefault();
          if (!ph.parentElement) return;
          let to = 0;
          for (const node of Array.from(container.children)) {
            if (node === ph) break;
            if (node.classList.contains('character')) to++;
          }
          ph.remove();
          const from = Number((document.querySelector('.character.dragging')||{}).dataset?.index||0);
          moveCharacter(from, to);
        });
        container.addEventListener('dragend', ()=>{ ph.remove(); });
      }

      /* ========= Task-level DnD ========= */
      function attachTaskDnD(card,c){
        const ph = document.createElement('div'); ph.className='task placeholder'; ph.innerHTML='<button class="drag-handle">⋮⋮</button><span></span><span></span><span></span>';
        let draggingEl=null, raf=null, taskRects=[];

        function staticTasks(){
          return Array.from(card.querySelectorAll('.task:not(.placeholder):not(.dragging)'));
        }
        function computeIndexFromY(y){
          const tasks = staticTasks();
          if(!tasks.length) return 0;
          if(!taskRects.length) taskRects = tasks.map(el=>el.getBoundingClientRect());
          let best=0, bestDist=Infinity;
          for(let i=0;i<taskRects.length;i++){
            const r=taskRects[i]; const cy=r.top+r.height/2; const dy = cy - y; const dist=dy*dy;
            if(dist<bestDist){ bestDist=dist; best=i; }
          }
          const r=taskRects[best]; const before = y < (r.top + r.height/2);
          return before ? best : best + 1;
        }
        function placePhAt(idx){
          const tasks = staticTasks();
          if(idx<=0){ const first=tasks[0]; if(first && ph!==first) card.insertBefore(ph, first); else if(!first) card.appendChild(ph); return; }
          if(idx>=tasks.length){ card.appendChild(ph); return; }
          const ref = tasks[idx]; if(ref && ph!==ref) card.insertBefore(ph, ref);
        }

        card.addEventListener('dragstart', (e)=>{
          const row = e.target.closest('.task');
          if(!row || row.classList.contains('placeholder')) return;
          draggingEl=row;
          row.classList.add('dragging');
          taskRects = [];
          placePhAt(staticTasks().indexOf(row) + 1);
        });

        card.addEventListener('dragover', (e)=>{
          if(!draggingEl) return;
          e.preventDefault();
          const y = e.clientY;
          if(raf) return;
          raf = requestAnimationFrame(()=>{
            raf=null;
            const idx = computeIndexFromY(y);
            placePhAt(idx);
          });
        });

        card.addEventListener('drop', (e)=>{
          if(!draggingEl || !ph.parentElement) return;
          e.preventDefault();
          let to = 0; const nodes = Array.from(card.children);
          for(const node of nodes){
            if(node === ph) break;
            if(node.classList.contains('task') && !node.classList.contains('placeholder')) to++;
          }
          const from = Number(draggingEl.dataset.taskIndex)||0;
          ph.remove(); draggingEl.classList.remove('dragging'); draggingEl=null; taskRects=[];
          const d=loadData();
          swapTasksInData(d,c,from,to);
          buildChecklists();
        });

        card.addEventListener('dragend', ()=>{
          ph.remove(); if(draggingEl){ draggingEl.classList.remove('dragging'); draggingEl=null; }
        });
      }

      function renderCheckAll(card,c){
        const row=document.createElement('div'); row.className='checkall-row';
        const box=document.createElement('input'); box.type='checkbox'; box.id=`checkall-${c}`;
        const lbl=document.createElement('label'); lbl.setAttribute('for',`checkall-${c}`); lbl.textContent='Check All';
        box.addEventListener('change',()=>{
          const cbs=card.querySelectorAll('.task input[type="checkbox"]');
          cbs.forEach((cb,idx)=>{ cb.checked=box.checked; localStorage.setItem(dailyKey(c,idx), box.checked?'true':'false'); });
        });
        row.append(box,lbl);
        card.appendChild(row);
        refreshMaster(card,c);
      }
      function refreshMaster(card,c){
        const master=card.querySelector(`#checkall-${c}`); if(!master) return;
        const cbs=card.querySelectorAll('.task input[type="checkbox"]');
        const allChecked = Array.from(cbs).every(cb=>cb.checked);
        master.checked = allChecked;
        master.indeterminate = !allChecked && Array.from(cbs).some(cb=>cb.checked);
      }

      function confirmDeleteModal(name){
        return new Promise(resolve=>{
          const overlay = document.getElementById('confirm-overlay');
          const title = document.getElementById('confirm-title');
          const msg = document.getElementById('confirm-msg');
          const ok = document.getElementById('confirm-ok');
          const cancel = document.getElementById('confirm-cancel');
          title.textContent = 'Confirm Delete';
          msg.textContent = `Are you sure you want to delete the character: ${name}?`;
          let done = false;
          function close(val){
            if(done) return; done = true;
            overlay.classList.remove('show');
            overlay.setAttribute('aria-hidden','true');
            cleanup();
            resolve(val);
          }
          function cleanup(){
            ok.removeEventListener('click', onOk);
            cancel.removeEventListener('click', onCancel);
            overlay.removeEventListener('click', onOverlay);
            document.removeEventListener('keydown', onKey);
          }
          function onOk(e){ e.preventDefault(); close(true); }
          function onCancel(e){ e.preventDefault(); close(false); }
          function onOverlay(e){ if(e.target === overlay) close(false); }
          function onKey(e){ if(e.key === 'Escape') close(false); }

          ok.addEventListener('click', onOk);
          cancel.addEventListener('click', onCancel);
          overlay.addEventListener('click', onOverlay);
          document.addEventListener('keydown', onKey);

          overlay.classList.add('show');
          overlay.setAttribute('aria-hidden','false');
          cancel.focus();
        });
      }

      (function initAvatarModal(){
        const overlay=document.getElementById('avatar-modal-overlay');
        const nameInput=document.getElementById('avatar-name');
        const errBox=document.getElementById('avatar-error');

        window.openAvatarModal = function(cardIndex,prefill){
          avatarTargetIndex=cardIndex; errBox.textContent="";
          const inputVal = (prefill||"").trim();
          nameInput.value = inputVal;
          overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false'); nameInput.focus(); nameInput.select();
        };
        function closeAvatarModal(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); avatarTargetIndex=null; }
        document.getElementById('avatar-cancel').onclick=closeAvatarModal;
        document.getElementById('avatar-search').onclick=()=>doAvatarSearch();
        document.getElementById('avatar-delete').onclick=()=>doAvatarDelete();
        document.getElementById('avatar-upload').onclick=()=>{
          if(avatarTargetIndex==null) return;
          uploadTargetIndex = avatarTargetIndex;
          document.getElementById('hidden-upload').click();
        };
        nameInput.addEventListener('keydown',e=>{ if(e.key==='Enter') { e.preventDefault(); doAvatarSearch(); } });

        async function doAvatarSearch(){
          errBox.textContent=""; const nm=nameInput.value.trim();
          if(!nm){ errBox.textContent='Please enter a character name.'; return; }
          try{
            const resp = await fetch(`${PROXY_URL}?name=${encodeURIComponent(nm)}`);
            const data = await resp.json();
            if(!resp.ok) throw new Error(data && data.error || "Avatar fetch failed");
            const { imageUrl, level, job } = data;
            const d=loadData();
            const i=avatarTargetIndex;
            d.chars[i].image=imageUrl||""; d.chars[i].name=nm; d.chars[i].level=level||""; d.chars[i].job=job||"";
            saveData(d);
            const card = document.querySelector(`.character[data-index="${i}"]`);
            if(card){ showCharImage(card,imageUrl||""); showCharMeta(card,level||"",job||""); const nameField=card.querySelector('.char-name'); if(nameField) nameField.value=nm; }
            closeAvatarModal();
          }catch(e){
            const d=loadData(); const i=avatarTargetIndex;
            d.chars[i].image=""; d.chars[i].level=""; d.chars[i].job=""; saveData(d);
            const card = document.querySelector(`.character[data-index="${i}"]`);
            if(card){ showCharImage(card,""); showCharMeta(card,"",""); }
            errBox.textContent='Could not find that character on MapleRanks. Reverted to base model — please double-check the name and try again.';
          }
        }
        function doAvatarDelete(){
          const d=loadData(); const i=avatarTargetIndex;
          d.chars[i].image=""; d.chars[i].level=""; d.chars[i].job=""; saveData(d);
          const card = document.querySelector(`.character[data-index="${i}"]`); if(card){ showCharImage(card,""); showCharMeta(card,"",""); }
          closeAvatarModal();
        }

        const hiddenUpload = document.getElementById('hidden-upload');
        hiddenUpload.addEventListener('change', async (e)=>{
          const file = e.target.files && e.target.files[0];
          if(!file || uploadTargetIndex==null) return;
          try{
            const dataUrl = await resizeImageFile(file, MAX_W, MAX_H);
            const d=loadData();
            d.chars[uploadTargetIndex].image = dataUrl; saveData(d);
            const card = document.querySelector(`.character[data-index="${uploadTargetIndex}"]`);
            if(card) showCharImage(card, dataUrl);
            closeAvatarModal();
          }catch(err){ alert('Could not load that image. Please try a different file.'); }
          finally{ e.target.value = ''; uploadTargetIndex = null; }
        });
      })();

      async function tryAutoFetchName(c, nm, card){
        if(!nm) return;
        try{
          const resp = await fetch(`${PROXY_URL}?name=${encodeURIComponent(nm)}`);
          const data = await resp.json();
          if(!resp.ok) throw new Error(data && data.error || "Avatar fetch failed");
          const { imageUrl, level, job } = data;
          const d=loadData();
          d.chars[c].image=imageUrl||""; d.chars[c].name=nm; d.chars[c].level=level||""; d.chars[c].job=job||"";
          saveData(d);
          showCharImage(card,imageUrl||""); showCharMeta(card, level||"", job||"");
        }catch(e){
          const d=loadData();
          d.chars[c].image=""; d.chars[c].level=""; d.chars[c].job=""; saveData(d);
          showCharImage(card, ""); showCharMeta(card, "", "");
        }
      }

      function resizeImageFile(file, maxW, maxH){
        return new Promise((resolve,reject)=>{
          const reader = new FileReader();
          reader.onload = ()=>{
            const img = new Image();
            img.onload = ()=>{
              const ratio = Math.min(maxW/img.width, maxH/img.height, 1);
              const nw = Math.round(img.width*ratio), nh = Math.round(img.height*ratio);
              const canvas = document.createElement('canvas');
              canvas.width = nw; canvas.height = nh;
              const ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
              ctx.drawImage(img, 0, 0, nw, nh);
              resolve(canvas.toDataURL('image/png'));
            };
            img.onerror = reject; img.src = reader.result;
          };
          reader.onerror = reject; reader.readAsDataURL(file);
        });
      }

      /* ========= Export / Import ========= */
      function collectAll({ includeDaily = false } = {}) {
        const theme     = localStorage.getItem('mapleTheme')    ?? 'lavender';
        const instrMin  = localStorage.getItem('mapleInstrMin') ?? '0';
        const presets   = {};
        for (let p = 1; p <= 3; p++) {
          const raw = localStorage.getItem(`mapleData_preset${p}`);
          presets[p] = raw ? JSON.parse(raw) : null;
        }
        const daily = {};
        if (includeDaily) {
          for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k && k.startsWith('mapleCheck_')) daily[k] = localStorage.getItem(k);
          }
        }
        return { schema: "maple-dailies.v2", exportedAtUTC: new Date().toISOString(), theme, instrMin, presets, daily };
      }
      function restoreAll(payload) {
        if (!payload || (payload.schema!=="maple-dailies.v1" && payload.schema!=="maple-dailies.v2")) throw new Error("This backup file is not recognized.");
        localStorage.setItem('mapleTheme', payload.theme || 'lavender');
        localStorage.setItem('mapleInstrMin', payload.instrMin ?? '0');
        if (payload.presets && typeof payload.presets === 'object') {
          for (let p = 1; p <= 3; p++) {
            let obj = payload.presets[p] || null;
            if (obj){
              if(obj.version!==2){ obj = migrateV1toV2(obj); }
              localStorage.setItem(`mapleData_preset${p}`, JSON.stringify(obj));
            } else {
              localStorage.removeItem(`mapleData_preset${p}`);
            }
          }
        }
        if (payload.daily && typeof payload.daily === 'object') {
          for (const [k, v] of Object.entries(payload.daily)) localStorage.setItem(k, v);
        }
        const themeSel = document.getElementById('theme');
        const theme = localStorage.getItem('mapleTheme') || 'lavender';
        document.body.className = theme; if (themeSel) themeSel.value = theme;
        const presetSel = document.getElementById('preset'); if (presetSel) presetSel.value = "1"; switchPreset("1");
      }
      function exportData({ includeDaily = false } = {}) {
        const data = collectAll({ includeDaily });
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        const stamp = new Date().toISOString().slice(0,10);
        a.href = URL.createObjectURL(blob);
        a.download = `maple-dailies-${stamp}.json`;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      }
      async function importDataFromFile(file) {
        const text = await file.text();
        const json = JSON.parse(text);
        restoreAll(json);
        buildChecklists();
        const clip = document.getElementById('clipboard'); if (clip) { clip.textContent = 'Data imported.'; setTimeout(()=>clip.textContent='', 2000); }
      }
      (function initPortableBackup(){
        const exportBtn = document.getElementById('export-btn');
        const importBtn = document.getElementById('import-btn');
        const fileInput = document.getElementById('import-file');
        if (exportBtn) exportBtn.addEventListener('click', () => exportData({ includeDaily:false }));
        if (importBtn && fileInput) {
          importBtn.addEventListener('click', () => fileInput.click());
          fileInput.addEventListener('change', async (e) => {
            const f = e.target.files && e.target.files[0];
            if (!f) return;
            try { await importDataFromFile(f); }
            catch (err) { alert('Import failed: ' + (err.message || err)); }
            finally { e.target.value = ''; }
          });
        }
      })();

      function switchPreset(p){ currentPreset = Number(p)||1; buildChecklists(); }

      (function initControls(){
        const themeSel = document.getElementById('theme');
        const presetSel = document.getElementById('preset');
        const addBtn = document.getElementById('add-character-btn');
        function loadTheme(){ const t=localStorage.getItem('mapleTheme')||'lavender'; document.body.className=t; themeSel.value=t; }
        themeSel.addEventListener('change',function(){ document.body.className=this.value; localStorage.setItem('mapleTheme',this.value); });
        presetSel.addEventListener('change',function(){ switchPreset(this.value); });
        addBtn.addEventListener('click', addCharacter);
        loadTheme();
      })();

      (function initInstructions(){
        const instr=document.getElementById('instructions'); const toggle=document.getElementById('instr-toggle');
        function setInstr(min){ instr.classList.toggle('minimized',min); toggle.textContent=min?'Unhide':'Hide'; localStorage.setItem('mapleInstrMin',min?'1':'0'); }
        toggle.onclick=()=>setInstr(!instr.classList.contains('minimized'));
        setInstr(localStorage.getItem('mapleInstrMin')==='1');
      })();

      function buildChecklists(){
        const container=document.getElementById('checklists'); container.innerHTML='';
        const d=loadData();
        d.chars.forEach((ch, c)=>{
          const card=document.createElement('div'); card.className='character'; card.dataset.index=c; card.setAttribute('draggable','true');

          card.addEventListener('dragstart', (e)=>{
            document.querySelectorAll('.character').forEach(el => el.classList.remove('dragging'));
            card.classList.add('dragging');
            precomputeCardRects(container);
            const img = new Image(); img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABAgEAx7H2qQAAAABJRU5ErkJggg==';
            e.dataTransfer.setDragImage(img, 0, 0);
            e.dataTransfer.effectAllowed='move';
          });
          card.addEventListener('dragend',()=>{ card.classList.remove('dragging'); });

          const topRight=document.createElement('div'); topRight.className='window-controls-right';
          const cam=document.createElement('button'); cam.className='icon-btn'; cam.title='Set Avatar'; cam.innerHTML='<svg viewBox="0 0 24 24"><path fill="currentColor" d="M9 3l-1.5 2H5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2.5L15 3H9zm3 4a5 5 0 1 1 0 10a5 5 0 0 1 0-10z"/></svg>';
          cam.onclick=()=>openAvatarModal(c,(loadData().chars[c].name||""));
          const dup=document.createElement('button'); dup.className='icon-btn'; dup.title='Duplicate'; dup.innerHTML='<svg viewBox="0 0 24 24"><path fill="currentColor" d="M16 1H6a2 2 0 0 0-2 2v10h2V3h10V1zm-4 4h8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H12a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2zm0 2v10h8V7h-8z"/></svg>';
          dup.onclick=()=>duplicateCharacter(c);
          const close=document.createElement('button'); close.className='icon-btn'; close.title='Delete'; close.innerHTML='&times;';
          close.onclick=()=>deleteCharacter(c);
          topRight.append(cam,dup,close);
          card.appendChild(topRight);

          const imgWrap=document.createElement('div'); imgWrap.className='char-image-wrap'; imgWrap.innerHTML='<img alt="Character image" />'; card.appendChild(imgWrap);
          const meta=document.createElement('div'); meta.className='char-meta'; card.appendChild(meta);
          showCharImage(card, ch.image||""); showCharMeta(card, ch.level||"", ch.job||"");

          const name=document.createElement('input'); name.className='char-name'; name.placeholder='Character Name'; name.value=ch.name||"";
          name.addEventListener('input',()=>{ const dd=loadData(); dd.chars[c].name=name.value; saveData(dd); });
          name.addEventListener('keydown',async e=>{
            const atStart=name.selectionStart===0&&name.selectionEnd===0; const atEnd=name.selectionStart===name.value.length&&name.selectionEnd===name.value.length;
            if(e.key==='Enter'){
              e.preventDefault();
              await tryAutoFetchName(c, name.value.trim(), card);
              (card.querySelector('.task input[type="text"]')||{}).focus?.();
            } else if(e.key==='ArrowRight'&&atEnd){ e.preventDefault(); focusCardByOffset(card,+1); }
            else if(e.key==='ArrowLeft'&&atStart){ e.preventDefault(); focusCardByOffset(card,-1); }
          });
          name.addEventListener('blur', async ()=>{
            const val = name.value.trim(); if(val) await tryAutoFetchName(c,val,card);
          });
          card.appendChild(name);

          // Master Check All
          renderCheckAll(card,c);

          ch.tasks.forEach((_,t)=> createTaskLine(card, d, c, t));
          attachTaskDnD(card,c);

          container.appendChild(card);
        });

        if(!gridDnDBound){
          attachGridDnD(container);
          gridDnDBound = true;
        }

        if(pendingFocus){
          const {cardIndex, taskIndex} = pendingFocus;
          const target = document.querySelector(`.character[data-index="${cardIndex}"]`);
          if(target) focusTaskAt(target, taskIndex);
          pendingFocus = null;
        }
      }
      buildChecklists();

    }catch(err){
      console.error('Init failed:', err);
    }
  })();
  </script>
</body>
</html>
